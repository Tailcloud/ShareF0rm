"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Promise = require("bluebird");
const url = require("url");
const util = require("util");
const _ = require("lodash");
const fs = require("fs");
const request = require("request-promise");
const cookie = require("cookie");
const path = require("path");
let xmldoc = require('xmldoc');
const Cache_1 = require("./../../utils/Cache");
const consts = require("./../../Consts");
const AdfsHelper_1 = require("./../../utils/AdfsHelper");
class OnlineUserCredentials {
    constructor(_siteUrl, _authOptions) {
        this._siteUrl = _siteUrl;
        this._authOptions = _authOptions;
        this._authOptions = _.extend({}, _authOptions);
        this._authOptions.username = this._authOptions.username
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        this._authOptions.password = this._authOptions.password
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }
    getAuth() {
        let parsedUrl = url.parse(this._siteUrl);
        let host = parsedUrl.host;
        let cacheKey = util.format('%s@%s', host, this._authOptions.username);
        let cachedCookie = OnlineUserCredentials.CookieCache.get(cacheKey);
        if (cachedCookie) {
            return Promise.resolve({
                headers: {
                    'Cookie': cachedCookie
                }
            });
        }
        return this.getSecurityToken()
            .then(xmlResponse => {
            return this.postToken(xmlResponse);
        })
            .then(data => {
            let response = data[1];
            let diffSeconds = data[0];
            let fedAuth;
            let rtFa;
            for (let i = 0; i < response.headers['set-cookie'].length; i++) {
                let headerCookie = response.headers['set-cookie'][i];
                if (headerCookie.indexOf(consts.FedAuth) !== -1) {
                    fedAuth = cookie.parse(headerCookie)[consts.FedAuth];
                }
                if (headerCookie.indexOf(consts.RtFa) !== -1) {
                    rtFa = cookie.parse(headerCookie)[consts.RtFa];
                }
            }
            let authCookie = 'FedAuth=' + fedAuth + '; rtFa=' + rtFa;
            OnlineUserCredentials.CookieCache.set(cacheKey, authCookie, diffSeconds);
            return {
                headers: {
                    'Cookie': authCookie
                }
            };
        });
    }
    ;
    getSecurityToken() {
        return request.post(consts.OnlineUserRealmEndpoint, {
            simple: false,
            strictSSL: false,
            json: true,
            form: {
                'login': this._authOptions.username
            }
        })
            .then(userRealm => {
            let authType = userRealm.NameSpaceType;
            if (!authType) {
                throw new Error('Unable to define namespace type for Online authentiation');
            }
            if (authType === 'Managed') {
                return this.getSecurityTokenWithOnline();
            }
            if (authType === 'Federated') {
                return this.getSecurityTokenWithAdfs(userRealm.AuthURL);
            }
            throw new Error(`Unable to resolve namespace authentiation type. Type received: ${authType}`);
        });
    }
    getSecurityTokenWithAdfs(adfsUrl) {
        return AdfsHelper_1.AdfsHelper.getSamlAssertion(this._siteUrl, {
            username: this._authOptions.username,
            password: this._authOptions.password,
            adfsUrl: adfsUrl,
            relyingParty: consts.AdfsOnlineRealm
        })
            .then(samlAssertion => {
            let siteUrlParsed = url.parse(this._siteUrl);
            let rootSiteUrl = siteUrlParsed.protocol + '//' + siteUrlParsed.host;
            let tokenRequest = _.template(fs.readFileSync(path.join(__dirname, '..', '..', '..', 'templates', 'online_saml_wsfed_adfs.tmpl')).toString())({
                endpoint: rootSiteUrl,
                token: samlAssertion.value
            });
            return request.post(consts.MSOnlineSts, {
                body: tokenRequest,
                headers: {
                    'Content-Length': tokenRequest.length,
                    'Content-Type': 'application/soap+xml; charset=utf-8'
                },
                simple: false,
                strictSSL: false
            });
        });
    }
    getSecurityTokenWithOnline() {
        let parsedUrl = url.parse(this._siteUrl);
        let host = parsedUrl.host;
        let spFormsEndPoint = `${parsedUrl.protocol}//${host}/${consts.FormsPath}`;
        let samlBody = _.template(fs.readFileSync(path.join(__dirname, '..', '..', '..', 'templates', 'online_saml_wsfed.tmpl')).toString())({
            username: this._authOptions.username,
            password: this._authOptions.password,
            endpoint: spFormsEndPoint
        });
        return request
            .post(consts.MSOnlineSts, {
            body: samlBody,
            simple: false,
            strictSSL: false,
            headers: {
                'Content-Type': 'application/soap+xml; charset=utf-8'
            }
        })
            .then(xmlResponse => {
            return xmlResponse;
        });
    }
    postToken(xmlResponse) {
        let xmlDoc = new xmldoc.XmlDocument(xmlResponse);
        let parsedUrl = url.parse(this._siteUrl);
        let spFormsEndPoint = `${parsedUrl.protocol}//${parsedUrl.host}/${consts.FormsPath}`;
        let securityTokenResponse = xmlDoc.childNamed('S:Body').firstChild;
        if (securityTokenResponse.name.indexOf('Fault') !== -1) {
            throw new Error(securityTokenResponse.toString());
        }
        let binaryToken = securityTokenResponse.childNamed('wst:RequestedSecurityToken').firstChild.val;
        let now = new Date().getTime();
        let expires = new Date(securityTokenResponse.childNamed('wst:Lifetime').childNamed('wsu:Expires').val).getTime();
        let diff = (expires - now) / 1000;
        let diffSeconds = parseInt(diff.toString(), 10);
        return Promise.all([diffSeconds, request
                .post(spFormsEndPoint, {
                headers: {
                    'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)',
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: binaryToken,
                rejectUnauthorized: false,
                resolveWithFullResponse: true,
                simple: false
            })]);
    }
}
OnlineUserCredentials.CookieCache = new Cache_1.Cache();
exports.OnlineUserCredentials = OnlineUserCredentials;
//# sourceMappingURL=OnlineUserCredentials.js.map