"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const url = require("url");
const request = require("request-promise");
const http = require("http");
const https = require("https");
let ntlm = require('httpntlm').ntlm;
class OnpremiseUserCredentials {
    constructor(_siteUrl, _authOptions) {
        this._siteUrl = _siteUrl;
        this._authOptions = _authOptions;
    }
    getAuth() {
        _.defaults(this._authOptions, { domain: '', workstation: '' });
        let ntlmOptions = _.assign({}, this._authOptions);
        ntlmOptions.url = this._siteUrl;
        let type1msg = ntlm.createType1Message(ntlmOptions);
        let isHttps = url.parse(this._siteUrl).protocol === 'https:';
        let keepaliveAgent = isHttps ? new https.Agent({ keepAlive: true, rejectUnauthorized: false }) :
            new http.Agent({ keepAlive: true });
        return request({
            url: this._siteUrl,
            method: 'GET',
            headers: {
                'Connection': 'keep-alive',
                'Authorization': type1msg,
                'Accept': 'application/json;odata=verbose'
            },
            agent: keepaliveAgent,
            resolveWithFullResponse: true,
            simple: false,
            strictSSL: false
        })
            .then((response) => {
            let type2msg = ntlm.parseType2Message(response.headers['www-authenticate']);
            let type3msg = ntlm.createType3Message(type2msg, ntlmOptions);
            return {
                headers: {
                    'Connection': 'Close',
                    'Authorization': type3msg
                },
                options: {
                    agent: keepaliveAgent
                }
            };
        });
    }
    ;
}
exports.OnpremiseUserCredentials = OnpremiseUserCredentials;
//# sourceMappingURL=OnpremiseUserCredentials.js.map